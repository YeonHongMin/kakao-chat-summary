"""
date_summarizer.py - ë‚ ì§œë³„ ìš”ì•½ ë©”ì¸ ëª¨ë“ˆ

ì¹´ì¹´ì˜¤í†¡ ëŒ€í™” íŒŒì¼ì„ ë‚ ì§œë³„ë¡œ íŒŒì‹±í•˜ê³ ,
ê° ë‚ ì§œì˜ ëŒ€í™”ë¥¼ ìš”ì•½í•˜ì—¬ í•˜ë‚˜ì˜ í†µí•© ë¦¬í¬íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

ì‚¬ìš©ë²•:
    python date_summarizer.py <filepath>              # ë‹¨ì¼ íŒŒì¼ (ê¸°ë³¸ LLM)
    python date_summarizer.py <directory>             # ë””ë ‰í„°ë¦¬ ì¼ê´„ ì²˜ë¦¬
    python date_summarizer.py --llm chatgpt <file>    # ChatGPT ì‚¬ìš©
    python date_summarizer.py                         # ëŒ€í™”í˜• ëª¨ë“œ
"""

import sys
from datetime import datetime
from pathlib import Path
from typing import List, Optional

from config import config, LLM_PROVIDERS
from parser import KakaoLogParser
from chat_processor import ChatProcessor
from url_extractor import extract_urls_from_text, save_urls_to_file

# ì „ì—­ ë¡œê±° ì¸ìŠ¤í„´ìŠ¤
logger = config.logger


class DateSummarizer:
    """
    ë‚ ì§œë³„ ëŒ€í™” ìš”ì•½ í´ë˜ìŠ¤.
    """
    
    def __init__(self, filepath: Path, provider: Optional[str] = None):
        """
        Args:
            filepath: ì²˜ë¦¬í•  ì¹´ì¹´ì˜¤í†¡ í…ìŠ¤íŠ¸ íŒŒì¼ ê²½ë¡œ
            provider: LLM ì œê³µì (glm, chatgpt, minimax, perplexity)
        """
        self.filepath = filepath
        self.parser = KakaoLogParser()
        self.processor = ChatProcessor(provider)
        self.output_file = filepath.parent / f"{filepath.stem}_summaries.md"

    def run(self) -> bool:
        """ë‚ ì§œë³„ ìš”ì•½ ì²˜ë¦¬ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤."""
        if not self.filepath.exists():
            logger.error(f"File not found: {self.filepath}")
            return False

        logger.info(f"Parsing file: {self.filepath.name}...")
        parse_result = self.parser.parse(self.filepath)
        
        if not parse_result.messages_by_date:
            logger.warning("No parsed messages found. Check file format.")
            return False

        sorted_dates = sorted(parse_result.messages_by_date.keys())
        logger.info(f"Found {parse_result.total_dates} dates.")
        
        self._initialize_output_file(len(sorted_dates))
        print(f"Processing {len(sorted_dates)} dates -> '{self.output_file.name}'")
        
        self._process_dates(sorted_dates, parse_result.messages_by_date)
        self._extract_all_urls()
        
        return True

    def _initialize_output_file(self, total_days: int):
        with open(self.output_file, 'w', encoding='utf-8') as f:
            f.write(f"# ğŸ“š ì¹´ì¹´ì˜¤í†¡ ëŒ€í™” ìš”ì•½ ë¦¬í¬íŠ¸\n")
            f.write(f"- **ì›ë³¸ íŒŒì¼**: {self.filepath.name}\n")
            f.write(f"- **ì´ ëŒ€í™” ì¼ìˆ˜**: {total_days}ì¼\n")
            f.write(f"- **LLM**: {config.get_provider_info().name}\n")
            f.write(f"- **ìƒì„± ì¼ì‹œ**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write("---\n\n")

    def _process_dates(self, dates: List[str], messages_map: dict):
        results = []
        total = len(dates)
        
        for idx, date_key in enumerate(dates, 1):
            messages = messages_map[date_key]
            current_status = f"[{idx}/{total}] {date_key} ({len(messages)} msgs)"
            print(f"  â–¶ {current_status} ìš”ì•½ ì¤‘...")
            
            chat_content = "\n".join(messages)
            summary_result = self.processor.process_summary(chat_content)
            
            if "[ERROR]" in summary_result:
                self._handle_error(date_key, summary_result)
                results.append(f"- {date_key}: âŒ ì‹¤íŒ¨")
            else:
                self._append_summary(date_key, len(messages), summary_result)
                results.append(f"- {date_key}: âœ… ì„±ê³µ")

        self._print_results(results)

    def _handle_error(self, date_key: str, error_msg: str):
        # ë¡œê·¸ íŒŒì¼ì— ìƒì„¸ ì—ëŸ¬ ê¸°ë¡
        logger.error(f"{date_key} ìš”ì•½ ì‹¤íŒ¨: {error_msg}")
        # ì½˜ì†”ì—ëŠ” ê°„ë‹¨í•œ ë©”ì‹œì§€ë§Œ
        print(f"    âŒ ì‹¤íŒ¨ (ë¡œê·¸ ì°¸ì¡°)")

    def _append_summary(self, date_key: str, msg_count: int, summary_md: str):
        clean_summary = self._strip_headers(summary_md)
        
        with open(self.output_file, 'a', encoding='utf-8') as f:
            f.write(f"\n## ğŸ“… {date_key} ({msg_count} msg)\n\n")
            f.write(clean_summary)
            f.write("\n\n---\n")

    def _strip_headers(self, text: str) -> str:
        if "# ğŸ“" not in text:
            return text
            
        lines = text.split('\n')
        start_idx = 0
        end_idx = len(lines)
        
        for i, line in enumerate(lines):
            if line.startswith("###"):
                start_idx = i
                break
        
        for i in range(len(lines)-1, -1, -1):
            if "_Generated by" in lines[i]:
                end_idx = i
                break
                
        return "\n".join(lines[start_idx:end_idx]).strip() if start_idx < end_idx else text

    def _extract_all_urls(self):
        print(f"  ğŸ”— URL ì¶”ì¶œ ì¤‘...")
        try:
            full_text = self.output_file.read_text(encoding='utf-8')
            url_dict = extract_urls_from_text(full_text)
            
            if url_dict:
                url_filename = f"{self.filepath.stem}_url.txt"
                url_path = self.filepath.parent / url_filename
                save_urls_to_file(url_dict, str(url_path), self.filepath.stem)
                print(f"    âœ… {len(url_dict)}ê°œ URL ì¶”ì¶œ -> {url_filename}")
            else:
                print("    â„¹ï¸  ì¶”ì¶œëœ URLì´ ì—†ìŠµë‹ˆë‹¤.")
        except Exception as e:
            logger.error(f"URL extraction failed: {e}")

    def _print_results(self, results: List[str]):
        print("\n  ğŸ“‹ ë‚ ì§œë³„ ê²°ê³¼:")
        for res in results:
            print(f"    {res}")


class BatchProcessor:
    """ë””ë ‰í„°ë¦¬ ì¼ê´„ ì²˜ë¦¬ í´ë˜ìŠ¤."""
    
    def __init__(self, directory: Path, provider: Optional[str] = None):
        self.directory = directory
        self.provider = provider

    def get_target_files(self) -> List[Path]:
        all_txt_files = list(self.directory.glob("*.txt"))
        
        target_files = [
            f for f in all_txt_files
            if "_summary" not in f.name 
            and "_url" not in f.name
            and "_summaries" not in f.name
        ]
        
        return sorted(target_files)

    def run(self):
        if not self.directory.exists() or not self.directory.is_dir():
            print(f"âŒ ìœ íš¨í•˜ì§€ ì•Šì€ ë””ë ‰í„°ë¦¬: {self.directory}")
            return

        target_files = self.get_target_files()
        
        if not target_files:
            print(f"âŒ ì²˜ë¦¬í•  íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.")
            return

        print("="*60)
        print("ğŸ“ ë””ë ‰í„°ë¦¬ ì¼ê´„ ì²˜ë¦¬")
        print("="*60)
        print(f"ğŸ“‚ ë””ë ‰í„°ë¦¬: {self.directory}")
        print(f"ğŸ¤– LLM: {config.get_provider_info().name}")
        print(f"ğŸ“„ íŒŒì¼ ìˆ˜: {len(target_files)}ê°œ")
        print("="*60 + "\n")

        for i, f in enumerate(target_files, 1):
            print(f"   {i}. {f.name}")
        print()

        confirm = input("ê³„ì† ì§„í–‰í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (Y/n): ").strip().lower()
        if confirm == 'n':
            print("âŒ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.")
            return

        print("\n" + "-"*60)

        results = []
        total = len(target_files)
        
        for idx, filepath in enumerate(target_files, 1):
            print(f"\n[{idx}/{total}] ğŸ“„ {filepath.name}")
            
            try:
                summarizer = DateSummarizer(filepath, self.provider)
                success = summarizer.run()
                results.append((filepath.name, "âœ… ì„±ê³µ" if success else "âš ï¸ ìŠ¤í‚µ"))
            except Exception as e:
                logger.exception(f"Failed to process {filepath.name}")
                results.append((filepath.name, f"âŒ ì‹¤íŒ¨"))

        self._print_final_results(results)

    def _print_final_results(self, results: List[tuple]):
        print("\n" + "="*60)
        print("ğŸ“‹ ìµœì¢… ê²°ê³¼")
        print("="*60)
        
        success_count = sum(1 for _, status in results if "ì„±ê³µ" in status)
        
        for filename, status in results:
            print(f"  {status} {filename}")
        
        print("-"*60)
        print(f"ì´ {len(results)}ê°œ | âœ… ì„±ê³µ: {success_count} | ê¸°íƒ€: {len(results) - success_count}")


def prompt_api_key():
    """API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì€ ê²½ìš° ëŒ€í™”í˜•ìœ¼ë¡œ ì…ë ¥ ìš”ì²­."""
    if config.get_api_key():
        return

    provider_info = config.get_provider_info()
    print("\n" + "="*50)
    print(f"ğŸ”‘ API ì¸ì¦ ì„¤ì • ({provider_info.name})")
    print("="*50)
    print(f"í™˜ê²½ ë³€ìˆ˜ {provider_info.env_key}ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
    
    while True:
        try:
            input_key = input(f"ğŸ‘‰ {provider_info.name} API Key: ").strip()
            if input_key:
                config.set_api_key(input_key)
                print("âœ… API Keyê°€ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤.\n")
                break
            else:
                print("âš ï¸  API KeyëŠ” ë¹„ì–´ìˆì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
        except KeyboardInterrupt:
            print("\nâŒ í”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•©ë‹ˆë‹¤.")
            sys.exit(0)


def select_llm_provider() -> str:
    """LLM ì œê³µì ì„ íƒ í”„ë¡¬í”„íŠ¸."""
    print("\nğŸ¤– LLM ì œê³µì ì„ íƒ:")
    providers = list(LLM_PROVIDERS.keys())
    for i, key in enumerate(providers, 1):
        info = LLM_PROVIDERS[key]
        print(f"  {i}. {info.name} ({key})")
    
    while True:
        choice = input(f"\nì„ íƒ (1-{len(providers)}, ê¸°ë³¸=1): ").strip()
        if not choice:
            return providers[0]
        if choice.isdigit() and 1 <= int(choice) <= len(providers):
            return providers[int(choice) - 1]
        print("âš ï¸ ì˜¬ë°”ë¥¸ ë²ˆí˜¸ë¥¼ ì„ íƒí•˜ì„¸ìš”.")


def parse_args():
    """ëª…ë ¹ì¤„ ì¸ì íŒŒì‹±."""
    args = sys.argv[1:]
    provider = None
    target = None
    
    i = 0
    while i < len(args):
        if args[i] == "--llm" and i + 1 < len(args):
            provider = args[i + 1]
            i += 2
        else:
            target = args[i]
            i += 1
    
    return target, provider


def main():
    """ë©”ì¸ ì§„ì…ì  í•¨ìˆ˜."""
    target, provider = parse_args()
    
    # LLM ì œê³µì ì„¤ì •
    if provider:
        if provider not in LLM_PROVIDERS:
            print(f"âŒ ì•Œ ìˆ˜ ì—†ëŠ” LLM: {provider}")
            print(f"   ì‚¬ìš© ê°€ëŠ¥: {', '.join(LLM_PROVIDERS.keys())}")
            sys.exit(1)
        config.set_provider(provider)
    
    # ëª…ë ¹ì¤„ ì¸ì ì—†ìœ¼ë©´ ëŒ€í™”í˜• ëª¨ë“œ
    if not target:
        print("Usage:")
        print("  python date_summarizer.py <file>               # ë‹¨ì¼ íŒŒì¼")
        print("  python date_summarizer.py <directory>          # ë””ë ‰í„°ë¦¬")
        print("  python date_summarizer.py --llm chatgpt <file> # LLM ì§€ì •\n")
        
        # LLM ì„ íƒ
        selected_provider = select_llm_provider()
        config.set_provider(selected_provider)
        
        # íŒŒì¼/ë””ë ‰í„°ë¦¬ ì„ íƒ
        data_dir = config.data_dir
        if data_dir.exists():
            files = list(data_dir.glob("*.txt"))
            txt_files = [f for f in files if "_summary" not in f.name and "_url" not in f.name]
            
            if txt_files:
                print("\nAvailable files:")
                for i, f in enumerate(txt_files, 1):
                    print(f"  {i}. {f.name}")
                print(f"  A. ì „ì²´ ë””ë ‰í„°ë¦¬ ì²˜ë¦¬")
                
                choice = input("\nSelect (number/A/Enter to exit): ").strip()
                
                if choice.upper() == 'A':
                    prompt_api_key()
                    processor = BatchProcessor(data_dir, selected_provider)
                    processor.run()
                    sys.exit(0)
                elif choice.isdigit() and 1 <= int(choice) <= len(txt_files):
                    target_file = txt_files[int(choice)-1]
                    prompt_api_key()
                    summarizer = DateSummarizer(target_file, selected_provider)
                    summarizer.run()
                    sys.exit(0)
        sys.exit(1)

    # ëª…ë ¹ì¤„ ì¸ìë¡œ ê²½ë¡œê°€ ì£¼ì–´ì§„ ê²½ìš°
    target_path = Path(target).resolve()
    prompt_api_key()
    
    if target_path.is_dir():
        processor = BatchProcessor(target_path, provider)
        processor.run()
    else:
        summarizer = DateSummarizer(target_path, provider)
        summarizer.run()


if __name__ == "__main__":
    main()
